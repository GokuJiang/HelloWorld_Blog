---
layout: post
title: "JavaScript Functional Programming(II)"
date: 2016-07-20 17:26:20 +0800
author: Yongming
tags:
    - JavaScript
    - functional programming
    
---


###纯函数式编程

#### **纯函数的概念**
> 纯函数是这样一种函数,即相同的输入,永远会得到相同的输出,而且没有任何可观察的副作用

比如``slice``和``splice``,这两个函数的作用并无二致,但是,他们各自的方式却大不相同,但不管怎么说作用还是一样的。
``slice``符合纯函数的定义是因为对相同对输入它保证能返回相同的输出。而``splice``却会嚼烂调用它的那个数组,然后在吐出来,这样就会产生可观察到的副作用,即这个数组永远改变了。

```javascript
var xs = [1,2,3,4,5];

//纯函数
xs.slice(0,3) =>[1,2,3]
xs.slice(0,3) =>[1,2,3]
xs.slice(0,3) =>[1,2,3]

//非纯函数
xs.splice(0,3) =>[1,2,3]
xs.splice(0,3) =>[4,5]
xs.splice(0,3) =>[]
```

在函数式编程中,我们避免这种改变数据的方式。我们追求的是可靠的,每次都能返回同样结果的函数。

看另一个例子

```javascript

//不纯的
var minimum = 21
var checkAge = function(age) {

    return age >= minimum;
};


//纯函数
var checkAge = function(age) {
    
    var minimum = 21;
    return age >= minimum;
    
}
```

在不纯的版本中,``checkAge``的结果取决于``minimum``这个可变量的值。换句话说,它取决于系统状态(system status),这一点很不好,它引入了外部环境,从而增加了认知负荷(cognitive load)。

另一方面,使用纯函数的形式,就要做到自给自足。我们也可以让``minimum``成为一个不可变量。这样就能保证纯粹性,因为状态不会发生变化。要实现这个效果,我们就必须传教一个对象,然后调用``Object.freeze``方法:

```
var immutableState = Object.freeze({
    minimum:21
})
```

####副作用
>副作用是在计算结果的过程中,系统状态的一种变化,或者与外部世界进行的可观察交互
它包括:
- 更改文件系统
- 往数据库中插入记录
- 发送一个http请求
- 可变数据
- 打印/log
- 获取用户输入
- DOM查询
- 访问系统状态

概括来讲,只要函数外部环境发生交互都是副作用——这一点可能会让你怀疑无副作用编程的可行性。函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。这并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生。后面讲到 functor 和 monad 的时候我们会学习如何控制它们，目前还是尽量远离这些阴险的函数为好。副作用让一个函数变得不纯是有道理的：从定义上来说，纯函数必须要能够根据相同的输入返回相同的输出；如果函数需要跟外部事物打交道，那么就无法保证这一点了。我们来仔细了解下为何要坚持这种「相同输入得到相同输出」原则。注意，我们要复习一些高考数学知识了。

####*回顾下人教版教材数学必修一*

**教材中的定义:** 
> 设A，B是非空的数集，如果按照某种确定的对应关系f，使对于集合A中的任意一个数x，在集合B中都有唯一确定的数y和它对应，那么就称``f:A->B``为从集合A到集合B的一个函数，记作``y=f(x)``或$f(A)={y|f(x)=y,y\inB}$。

> 其中`x`叫作自变量, `y`叫因变量，集合`A`叫做函数的定义域，与`x`对应的`y`叫做函数值，函数值的集合`B`叫做函数的值域。
> 定义域，值域，对应法则称为函数的三要素。一般书写为  。若省略定义域，一般是指使函数有意义的集合。


